var __importDefault =
    (this && this.__importDefault) ||
    function (mod) {
        return mod && mod.__esModule ? mod : { default: mod }
    }
;(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports)
        if (v !== undefined) module.exports = v
    } else if (typeof define === 'function' && define.amd) {
        define([
            'require',
            'exports',
            'path',
            'abortcontroller-polyfill/dist/abortcontroller-polyfill-only',
            'common-tags',
            'fs-extra',
            './helpers/cache',
            './helpers/config',
            './helpers/files',
            './helpers/functions',
        ], factory)
    }
})(function (require, exports) {
    'use strict'
    Object.defineProperty(exports, '__esModule', { value: true })
    exports.onPostBuild = void 0
    const path_1 = __importDefault(require('path'))
    require('abortcontroller-polyfill/dist/abortcontroller-polyfill-only')
    const common_tags_1 = require('common-tags')
    const fs_extra_1 = require('fs-extra')
    const cache_1 = require('./helpers/cache')
    const config_1 = require('./helpers/config')
    const files_1 = require('./helpers/files')
    const functions_1 = require('./helpers/functions')
    const DEFAULT_FUNCTIONS_SRC = 'netlify/functions'
    const netlifyConfig = {
        redirects: [],
        headers: [],
        edge_handlers: [],
        functions: {
            '*': {},
        },
        build: undefined,
        plugins: [],
    }
    async function onPostBuild() {
        const PUBLISH_DIR = './public'
        const FUNCTIONS_SRC = DEFAULT_FUNCTIONS_SRC
        const cacheDir = (0, cache_1.normalizedCacheDir)(PUBLISH_DIR)
        console.log('onBuild')
        if ((0, fs_extra_1.existsSync)(path_1.default.join(FUNCTIONS_SRC, 'gatsby'))) {
            console.log((0, common_tags_1.stripIndent)`
    Detected the function "${path_1.default.join(
        FUNCTIONS_SRC,
        'gatsby'
    )}" that seem to have been generated by an old version of the Essential Gatsby plugin. 
The plugin no longer uses this and it should be deleted to avoid conflicts.\n`)
        }
        const neededFunctions = await (0, config_1.getNeededFunctions)(cacheDir)
        // await deleteFunctions(constants)
        if ((0, config_1.shouldSkipBundlingDatastore)()) {
            console.log('Creating site data metadata file')
            await (0, config_1.createMetadataFileAndCopyDatastore)(PUBLISH_DIR, cacheDir)
        }
        // @ts-ignore
        await (0, functions_1.writeFunctions)({ netlifyConfig, neededFunctions })
        // await modifyConfig({ netlifyConfig, cacheDir, neededFunctions })
        await (0, files_1.modifyFiles)({ netlifyConfig, neededFunctions })
        console.log('onPostBuild')
        for (const func of neededFunctions) {
            // await checkZipSize(path.join(FUNCTIONS_DIST, `__${func.toLowerCase()}.zip`))
        }
    }
    exports.onPostBuild = onPostBuild
})
/*export async function onSuccess() {
  // Pre-warm the lambdas as downloading the datastore file can take a while
  if (shouldSkipBundlingDatastore()) {
    const FETCH_TIMEOUT = 5000
    const controller = new AbortController()
    const timeout = setTimeout(() => {
      controller.abort()
    }, FETCH_TIMEOUT)

    for (const func of ['api', 'dsg', 'ssr']) {
      const url = `${process.env.DEPLOY_PRIME_URL}/.netlify/functions/__${func}`
      console.log(`Sending pre-warm request to: ${url}`)

      try {
        await fetch(url, { signal: controller.signal })
      } catch (error) {
        console.log('Pre-warm request was aborted', error)
      } finally {
        clearTimeout(timeout)
      }
    }
  }
}*/
